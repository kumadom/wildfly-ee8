# Kubernetes関連の設定メモ

## namespaces系の設定

### Podに対するデフォルトのリソース要求、制限の設定

LimitRangeのオブジェクトで設定することが可能。基本的にはPod毎にリソース要求、制限の設定をする必要がある。
ただし、万が一設定が漏れてしまった場合に単一の貪欲なPodによってnamespaceに割り当てられたCPU、メモリが
すべて消費されてしまうような事態を回避するために設定しておくことがベスト。

基本的には無限ループなどのレベルを抑えることが目的なため、CPU、メモリともに要求、制限値は余裕を持った数字を設定している。

- サンプルの実装
  
  `default-resource-limit.yaml`
  
  [Kubernetes API: Limit Ranges](https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/limit-range-v1/)

### Namespaceに対するクォータ（リソース割り当て）の設定

Namespaceに対してのリソースの割り当ての上限設定も可能であり、Pod数、ミリコアCPU、メモリ等に対しての設定が可能。

基本的にはPodの稼働数程度の制御で十分な範囲と思われる。

- サンプルの実装
  
  `resource-quota.yaml`

  [Kubernetes API: Resource Quota](https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/)

## Pod系の設定

`vertical pod autoscaler`というアドオン機能でリソース要求を自動的に調整可能らしい。きっと便利

### Podのリソース要求とリソース制限

ワーカーノードで動作するPodに対してのリソースを管理することが可能です。
このような設定をすることによって、Kubernetesのスケジュール設定（kube-scheduler）がクラスタを構成するノードのリソースを考慮することが可能となります。

リソース要求、リソース制限については適切な値を設定することでリソースを考慮した適切なスケジューリングを行うことが可能となりますが、
適切ではない値を設定しまった場合には、要求するPod数が実行できない、メモリ利用オーバーなどで頻繁にPodが強制停止させられるなどが発生する可能性があります。

- サンプルの実装
  
  `app-deployment.yaml`
  
  [Kubernetes API: Pod.Resources](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources)


```
# ノードのリソース確認
kubectl describe node docker-desktop

```

#### リソース要求

リソース要求の設定によって、Podが動作するために必要とするミリコア（※1）、メモリの指定をすることが可能です。
コントロールプレーンのスケジューラは、それらの設定値が確保できないNodeではPodの実行はできないものと判断します。
また、Podの実行が必要な場合に全ノードがリソースが確保できずに割り当て不可の場合にはPending状態となり、確保したい数のPodが実行できない状態になります。

　※1　1vCPUの単位時間あたりの何ミリ秒を割り当て可能にする必要があるか

#### リソース制限

1Podで利用可能なリソース（CPU、メモリ等）の上限を設定することが可能。
制限を超えてCPUを利用しようとするPodは要求が制限され、処理の遅延が発生するようになります。
また、メモリの上限を超過するような貪欲なPodに関しては強制終了されることになります。

このようなリソース消費に貪欲なPodを見過ごしてしまう場合、一つの貪欲なPodによるメモリリークなどを起因に
ワーカーノードにおけるそのほかのPodも処理ができなくなってしまう可能性が発生してしまいます。

なお、リソース制限に関してはオーバーコミット（ノードが持つ総量のリソースを超過してPodの上限値設定すること）が可能であり、
メモリリーク等によるパフォーマンスの劣化に対して（リソース制限による強制終了等）を楽観的な姿勢とすることも可能。

## ローリングアップデート

- ワークロードのバランスの維持の考慮
  
  コントロールプレーンのスケジューラに完全にお任せ状態にしてしまうと、いろいろな要因（※1）によって一つのノードにあるコンテナのPodがすべて稼働するといった状態が発生しうる。
  そのため、Deschedulerなどのツールなどを導入することによって、クラスタ内のノードへ適切に配置されることを実現するなどの対策が必要。
  
  ※1 スケジューラはクラスタ内の各ノードのリソース消費状態を参考に割り当てるため。

### Podのドレイン時の有効なPod数の制御

PodDisruptionBudgetsを利用することで、Podのドレイン時などにおける最小の有効なPos数の確保や、最大の無効状態にするPodの数を調整できる。

- サンプル実装
  
  `app-disruption-budget.yaml`
  
  [Kubernetes API: Pod Disruption Budget](https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/)


## その他

### アノテーションのルール

- 所有者を示すアノテーションを明示的に設定したほうがよい
  
  （開発環境は特に）用途不明の迷子となるオブジェクトが発生する可能性がよくあり、それらがもしも不要なオブジェクトである場合には無駄なリソースを消費していることになる。
  このような無駄なリソース消費を削減するために、オブジェクトには所有者の存在を確認できるようにアノテーションとして所有者を設定し、所有者が存在しない
  オブジェクトの場合には強制終了といったルールを設けておくことで不要なリソース消費を削減することができる。
  
  所有者のアノテーションには、組織のドメインを指定し、そのうえでnamespaceを共有するアカウントを識別することができるといい。
  
### 検証と監査

#### クラスターの検証

- Sonobuoy（ソナー内臓の対潜水艦用捜索機のことらしい）

Kubernetesクラスタの各種診断が行えるKubernetes設定の検証ツール

ただしDocker desktopでは`v0.55.1`時点では動作せず。未検証

#### Kubernetesクラスターの監査

[公式ガイド](https://k8guard.github.io/)

Kubernetesオブジェクトを監視し、違反をしたものについては違反内容を違反者へ通知、アクションを実行する。
Prometheusを利用して違反内容のメトリクスの取得、およびダッシュボードも提供する。

違反時にはそれらのオブジェクトを強制終了させることも可能だが、セーフモードとして監視・通知のみのモードも存在する。

また、カスタム設定も可能であり、プロジェクトで定めたルールに則っていないオブジェクトの検知も可能。


